/**
* DevExpress Analytics (core\utils\_jqueryUtils.d.ts)
* Version:  24.1.7
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
/// <reference types="jquery" />
/// <reference types="jquery" />
export interface IJQueryWrapper {
    isVisible: () => boolean;
    has: (target: HTMLElement) => boolean;
    is: (target: HTMLElement | string) => boolean;
    hasClass: (className: string) => boolean;
    outerWidth: () => number;
    outerHeight: () => number;
    width: (value?: number) => number;
    height: (value?: number) => number;
    empty: () => IJQueryWrapper;
    hide: () => IJQueryWrapper;
    show: () => IJQueryWrapper;
    find: (selector: string | IJQueryWrapper, filterVisible?: boolean) => IJQueryWrapper;
    eq: (index: number) => IJQueryWrapper;
    css: (styles: {
        [key: string]: string;
    } | string, value?: string) => string;
    children: (selector?: string) => IJQueryWrapper;
    closest: (selector: string) => IJQueryWrapper;
    slideToggle: (duration: number, callback: () => void) => void;
    removeClass: (className: string) => IJQueryWrapper;
    addClass: (className: string) => IJQueryWrapper;
    removeAttr: (attributeName: string) => IJQueryWrapper;
    attr: (attributeName: string, value: string) => IJQueryWrapper;
    offset: () => {
        left: number;
        top: number;
    };
    position: () => {
        left: number;
        top: number;
    };
    get: (index: number) => HTMLElement;
    append: (content: string | HTMLElement | IJQueryWrapper) => IJQueryWrapper;
    prev: () => IJQueryWrapper;
    parent: () => IJQueryWrapper;
    parents: (selector?: string) => IJQueryWrapper;
    prepend: (topElement: HTMLElement) => void;
    prependTo: (parent: HTMLElement) => void;
    scrollTop: (offset?: number) => number;
    scrollLeft: (offset?: number) => number;
    remove: () => void;
    appendTo: (element: HTMLElement) => IJQueryWrapper;
    text: (text: string) => IJQueryWrapper;
    html: (markup: string) => IJQueryWrapper;
    isInput: () => boolean;
    off: (eventName: string, handler: EventListenerOrEventListenerObject) => void;
    on: (eventName: string, handler: EventListenerOrEventListenerObject) => void;
    element: HTMLElement;
    length: number;
    [index: number]: HTMLElement;
}
export declare function $unwrap<T = HTMLElement>(_element: Element | HTMLElement | Array<HTMLElement> | Window | JQuery | IJQueryWrapper): T;
export declare function $createFromHtml(html: string): IJQueryWrapper;
export declare function $map<T, TResult>(target: Array<T> | {
    [key: string]: T;
}, predicate: (element: T, key: string | number) => TResult): Array<TResult>;
export declare const $dx: (_element: HTMLElement | HTMLElement[] | string | Window | JQuery) => IJQueryWrapper;
type DxDeferredState = 'pending' | 'resolved' | 'rejected';
export declare class DxDeferred<T = any> {
    _state?: DxDeferredState;
    _resultValue?: T[];
    _doneCallbacks?: Array<(...args: T[]) => void>;
    _failCallbacks?: Array<(...args: T[]) => void>;
    _alwaysCallbacks?: Array<() => void>;
    _tryUpdateState(state: DxDeferredState, data: T[]): boolean;
    _finalize?: (args: T[]) => void;
    resolve(...args: T[]): DxDeferred<T>;
    reject(...args: any[]): DxDeferred<T>;
    done(callback: (...args: T[]) => void): DxDeferred<T>;
    fail(callback: (...args: T[]) => void): DxDeferred<T>;
    then(callback: (...args: T[]) => void): any;
    catch(callback: (...args: any[]) => void): any;
    state(): DxDeferredState;
    always(callback: (...args: T[]) => void): DxDeferred<T>;
    promise(): DxPromise<T>;
    nativePromise(): Promise<T>;
    static when<T = any>(deferreds: DxPromise<T>[] | DxDeferred<T>[] | DxPromise<T>[]): DxDeferred<T[]>;
}
interface DxPromiseCallback<T> {
    (value: T, ...args: T[]): void;
}
export interface DxPromise<T = any> extends PromiseLike<T> {
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): DxPromise<TResult1 | TResult2>;
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): DxPromise<T | TResult>;
    done?: (callback: DxPromiseCallback<T>) => DxPromise<T>;
    fail?: (callback: DxPromiseCallback<any>) => DxPromise<T>;
    always?: (callback: DxPromiseCallback<any>) => DxPromise<T>;
    state?: () => DxDeferredState;
    readonly [Symbol.toStringTag]?: string;
}
export declare function createPromiseWithResolvers<T = any>(): {
    promise: Promise<T>;
    resolve: (value: T | PromiseLike<T>) => void;
    reject: (reason: any) => void;
};
export {};
