/**
* DevExpress Analytics (core\utils\_jqueryUtils.js)
* Version:  24.1.7
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
export function $unwrap(_element) {
    if (!!_element && 'length' in _element) {
        return _element[0];
    }
    return _element;
}
export function $createFromHtml(html) {
    const element = document.createElement('div');
    element.innerHTML = html.trim();
    return $dx(element.firstChild);
}
export function $map(target, predicate) {
    if (!target || typeof target !== 'object')
        return [];
    if (Array.isArray(target)) {
        return target.map(predicate);
    }
    return Object.keys(target).map((key) => predicate(target[key], key));
}
const slideToggle = (el, duration, callback, isDown) => {
    if (typeof duration === 'undefined')
        duration = 400;
    if (typeof isDown === 'undefined')
        isDown = false;
    el.style.overflow = 'hidden';
    if (isDown)
        el.style.display = 'block';
    const elStyles = window.getComputedStyle(el);
    const elHeight = parseFloat(elStyles.getPropertyValue('height'));
    const elPaddingTop = parseFloat(elStyles.getPropertyValue('padding-top'));
    const elPaddingBottom = parseFloat(elStyles.getPropertyValue('padding-bottom'));
    const elMarginTop = parseFloat(elStyles.getPropertyValue('margin-top'));
    const elMarginBottom = parseFloat(elStyles.getPropertyValue('margin-bottom'));
    const stepHeight = elHeight / duration;
    const stepPaddingTop = elPaddingTop / duration;
    const stepPaddingBottom = elPaddingBottom / duration;
    const stepMarginTop = elMarginTop / duration;
    const stepMarginBottom = elMarginBottom / duration;
    let start;
    function step(timestamp) {
        if (start === undefined)
            start = timestamp;
        const elapsed = timestamp - start;
        if (isDown) {
            el.style.height = (stepHeight * elapsed) + 'px';
            el.style.paddingTop = (stepPaddingTop * elapsed) + 'px';
            el.style.paddingBottom = (stepPaddingBottom * elapsed) + 'px';
            el.style.marginTop = (stepMarginTop * elapsed) + 'px';
            el.style.marginBottom = (stepMarginBottom * elapsed) + 'px';
        }
        else {
            el.style.height = elHeight - (stepHeight * elapsed) + 'px';
            el.style.paddingTop = elPaddingTop - (stepPaddingTop * elapsed) + 'px';
            el.style.paddingBottom = elPaddingBottom - (stepPaddingBottom * elapsed) + 'px';
            el.style.marginTop = elMarginTop - (stepMarginTop * elapsed) + 'px';
            el.style.marginBottom = elMarginBottom - (stepMarginBottom * elapsed) + 'px';
        }
        if (elapsed >= duration) {
            el.style.height = '';
            el.style.paddingTop = '';
            el.style.paddingBottom = '';
            el.style.marginTop = '';
            el.style.marginBottom = '';
            el.style.overflow = '';
            if (!isDown)
                el.style.display = 'none';
            if (typeof callback === 'function')
                callback();
        }
        else {
            window.requestAnimationFrame(step);
        }
    }
    window.requestAnimationFrame(step);
};
export const $dx = (_element) => {
    let _unwrapedElement = _element;
    if (!Array.isArray(_unwrapedElement)
        && typeof _element !== 'string'
        && _unwrapedElement?.nodeType !== Node.COMMENT_NODE) {
        _unwrapedElement = $unwrap(_element);
    }
    let element = null;
    let length = 0;
    const indexer = {};
    if (typeof _unwrapedElement === 'string') {
        element = document.querySelector(_unwrapedElement);
        const matched = Array.from(document.querySelectorAll(_unwrapedElement));
        matched.forEach((htmlElement, i) => indexer[i] = htmlElement);
        length = matched.length;
    }
    else if (Array.isArray(_unwrapedElement)) {
        element = _unwrapedElement[0];
        _unwrapedElement.forEach((htmlElement, i) => indexer[i] = htmlElement);
        length = _unwrapedElement.length;
    }
    else if (_unwrapedElement && typeof _unwrapedElement === 'object') {
        element = _unwrapedElement;
        indexer[0] = element;
        length = 1;
    }
    return {
        ...indexer,
        length: length,
        element: element,
        isVisible: () => {
            if (!element)
                return undefined;
            const style = getComputedStyle(element);
            return style.display !== 'none' && style.visibility !== 'hidden';
        },
        is: (target) => {
            if (typeof target === 'string') {
                return element?.matches(target);
            }
            else {
                return element === target;
            }
        },
        has: (target) => {
            return element?.contains(target);
        },
        hasClass: (className) => {
            if (!element)
                return undefined;
            return element.classList.contains(className);
        },
        width: (value) => {
            if (value && element)
                element.style.width = value + 'px';
            if (element instanceof Element)
                return element?.getBoundingClientRect().width;
            if (_element instanceof Window)
                return _element.innerWidth;
        },
        height: (value) => {
            if (value && element)
                element.style.height = value + 'px';
            if (element instanceof Element)
                return element?.getBoundingClientRect().height;
            if (_element instanceof Window)
                return _element.innerHeight;
        },
        outerWidth: () => {
            if (!element)
                return undefined;
            const totalWidth = element.offsetWidth;
            const horizontalPadding = parseFloat(getComputedStyle(element).paddingLeft) +
                parseFloat(getComputedStyle(element).paddingRight);
            const horizontalBorder = parseFloat(getComputedStyle(element).borderLeftWidth) +
                parseFloat(getComputedStyle(element).borderRightWidth);
            return totalWidth + horizontalPadding + horizontalBorder;
        },
        outerHeight: () => {
            if (!element)
                return undefined;
            const totalHeight = element.offsetHeight;
            const verticalPadding = parseFloat(getComputedStyle(element).paddingTop) +
                parseFloat(getComputedStyle(element).paddingBottom);
            const verticalBorder = parseFloat(getComputedStyle(element).borderTopWidth) +
                parseFloat(getComputedStyle(element).borderBottomWidth);
            const outerHeight = totalHeight + verticalPadding + verticalBorder;
            return outerHeight;
        },
        empty: () => {
            while (element?.firstChild) {
                element.removeChild(element.firstChild);
            }
            return $dx(element);
        },
        hide: () => { if (element)
            element.style.display = 'none'; return $dx(element); },
        show: () => { if (element)
            element.style.display = 'block'; return $dx(element); },
        find: (selector, filterVisible = false) => {
            if (!element)
                return $dx(undefined);
            if (selector instanceof HTMLElement) {
                return $dx(element.contains(selector) ? selector : undefined);
            }
            if (!(typeof selector === 'string')) {
                const targets = Array.from(selector).filter(x => element.contains(x));
                return $dx(targets);
            }
            if (selector.indexOf(':visible') !== -1) {
                filterVisible = true;
                selector = selector.split(':visible')[0];
            }
            const visibleElements = Array.from(element.querySelectorAll(selector));
            let result = visibleElements.map(x => $dx(x));
            if (filterVisible)
                result = result.filter(x => x.isVisible());
            return result[0] || $dx(undefined);
        },
        eq: (index) => {
            return $dx(indexer[index]);
        },
        closest: (selector) => {
            let currentElement = element;
            while (currentElement) {
                if (currentElement.matches?.(selector)) {
                    return $dx(currentElement);
                }
                currentElement = currentElement.parentElement;
            }
            return $dx(undefined);
        },
        css: (styles, value) => {
            if (!element)
                return undefined;
            if (typeof styles === 'string') {
                value && element.style.setProperty(styles, value.toString());
                return getComputedStyle(element)[styles] || '';
            }
            else if (typeof styles === 'object') {
                for (const property in styles) {
                    if (styles.hasOwnProperty(property)) {
                        element.style.setProperty(property, styles[property]);
                    }
                }
            }
        },
        children: (selector) => {
            if (!element)
                return $dx(undefined);
            const children = element.children;
            const filteredChildren = Array.from(children).filter(child => selector ? child.matches(selector) : true);
            return $dx(filteredChildren) || $dx(undefined);
        },
        addClass: (className) => {
            if (!element)
                return $dx(element);
            const classNames = className.split(' ');
            classNames.forEach(name => name && element.classList.add(name));
            return $dx(element);
        },
        removeClass: (className) => {
            if (!element)
                return $dx(element);
            const classNames = className.split(' ');
            classNames.forEach(name => name && element.classList.remove(name));
            return $dx(element);
        },
        parent: () => {
            if (!element)
                return $dx(element);
            return $dx(element.parentElement);
        },
        parents: (selector) => {
            const parents = [];
            let currentParent = element?.parentElement;
            while (currentParent) {
                if (!selector || currentParent.matches(selector)) {
                    parents.push(currentParent);
                }
                currentParent = currentParent.parentElement;
            }
            return $dx(parents);
        },
        offset: () => {
            if (!element)
                return undefined;
            const rect = element.getBoundingClientRect();
            return { left: rect.left + window.scrollX, top: rect.top + window.scrollY };
        },
        position: () => {
            if (!element)
                return undefined;
            const rect = element.getBoundingClientRect();
            const offsetParent = element.offsetParent;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const offsetLeft = rect.left + scrollLeft - (offsetParent ? offsetParent.offsetLeft : 0);
            const offsetTop = rect.top + scrollTop - (offsetParent ? offsetParent.offsetTop : 0);
            return {
                left: offsetLeft,
                top: offsetTop,
            };
        },
        get: (index) => {
            return indexer[index];
        },
        append: (content) => {
            if (!element || !content)
                return;
            if (typeof content === 'string') {
                const tempElement = document.createElement('div');
                tempElement.innerHTML = content.trim();
                while (tempElement.firstChild) {
                    element.appendChild(tempElement.firstChild);
                }
            }
            else if (content instanceof HTMLElement) {
                element.appendChild(content);
            }
            else {
                Array.from(content).forEach(contentElement => element.appendChild(contentElement));
            }
            return $dx(element);
        },
        scrollTop: (offset) => {
            if (!element)
                return undefined;
            if (offset)
                element.scrollTop = offset;
            else
                return element.scrollTop;
        },
        scrollLeft: (offset) => {
            if (!element)
                return undefined;
            if (offset)
                element.scrollLeft = offset;
            else
                return element.scrollLeft;
        },
        prepend: (topElement) => {
            if (!element)
                return;
            element.prepend(topElement);
        },
        prependTo: (parent) => {
            if (!element || !parent)
                return;
            parent.prepend(element);
            return $dx(element);
        },
        prev: () => {
            return $dx(element?.previousSibling);
        },
        appendTo: (parent) => {
            if (!element)
                return;
            parent.appendChild(element);
            return $dx(element);
        },
        remove: () => {
            if (!element)
                return;
            element.remove();
        },
        text: (text) => {
            if (!element)
                return;
            element.textContent = text;
            return $dx(element);
        },
        html: (markup) => {
            if (!element)
                return;
            element.innerHTML = markup;
            return $dx(element);
        },
        slideToggle: (duration = 400, callback = () => void (0)) => {
            if (!element)
                return;
            if (element.clientHeight === 0) {
                slideToggle(element, duration, callback, true);
            }
            else {
                slideToggle(element, duration, callback, false);
            }
        },
        isInput: () => {
            return element?.matches('input, select, textarea, button, object');
        },
        off: (eventName, handler) => {
            if (!element)
                return;
            element.removeEventListener(eventName, handler);
        },
        on: (eventName, handler) => {
            if (!element)
                return;
            element.addEventListener(eventName, handler);
        },
        attr: (attributeName, value) => {
            if (!element)
                return $dx(element);
            element.setAttribute(attributeName, value);
            return $dx(element);
        },
        removeAttr: (attributeName) => {
            if (!element)
                return $dx(element);
            element.removeAttribute(attributeName);
            return $dx(element);
        },
    };
};
export class DxDeferred {
    constructor() {
        this._state = 'pending';
        this._doneCallbacks = [];
        this._failCallbacks = [];
        this._alwaysCallbacks = [];
        this._finalize = (args) => {
            this._alwaysCallbacks.forEach(callback => callback());
            this._doneCallbacks = [];
            this._failCallbacks = [];
            this._alwaysCallbacks = [];
        };
    }
    _tryUpdateState(state, data) {
        if (this._state !== 'pending')
            return false;
        this._state = state;
        this._resultValue = data;
        return true;
    }
    resolve(...args) {
        if (!this._tryUpdateState('resolved', args))
            return this;
        this._doneCallbacks.forEach(callback => callback(...args));
        this._finalize(args);
        return this;
    }
    reject(...args) {
        if (!this._tryUpdateState('rejected', args))
            return this;
        this._failCallbacks.forEach(callback => callback(...args));
        this._finalize(args);
        return this;
    }
    done(callback) {
        if (this._state === 'resolved') {
            callback(...(this._resultValue ?? []));
        }
        else if (this._state === 'pending') {
            this._doneCallbacks.push(callback);
        }
        return this;
    }
    fail(callback) {
        if (this._state === 'rejected') {
            callback(...(this._resultValue ?? []));
        }
        else if (this._state === 'pending') {
            this._failCallbacks.push(callback);
        }
        return this;
    }
    then(callback) {
        this.done((...result) => setTimeout(() => callback(...result)));
        return this;
    }
    catch(callback) {
        this.fail((...reason) => setTimeout(() => callback(...reason)));
        return this;
    }
    state() {
        return this._state;
    }
    always(callback) {
        if (this._state !== 'pending') {
            callback(...(this._resultValue ?? []));
        }
        else {
            this._alwaysCallbacks.push(callback);
        }
        return this;
    }
    promise() {
        return new DxPromiseImp(this);
    }
    nativePromise() {
        return new Promise((resolve, reject) => {
            if (this._state === 'rejected') {
                reject(this._resultValue[0]);
            }
            else if (this._state === 'resolved') {
                resolve(this._resultValue[0]);
            }
            else {
                this._doneCallbacks.push(resolve);
                this._failCallbacks.push(reject);
            }
        });
    }
    static when(deferreds) {
        const remain = [...deferreds];
        const rootDeferred = new DxDeferred();
        const resultArray = [];
        deferreds.forEach((deferred) => {
            deferred.done((result) => {
                resultArray.push(result);
                remain.splice(remain.indexOf(deferred), 1);
                if (remain.length === 0) {
                    rootDeferred.resolve(resultArray);
                }
            });
            deferred.fail(() => rootDeferred.reject());
        });
        if (remain.length === 0) {
            rootDeferred.resolve(resultArray);
        }
        return rootDeferred;
    }
}
export function createPromiseWithResolvers() {
    let resolve, reject;
    const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });
    return { promise, resolve, reject };
}
class DxPromiseImp {
    _isPromise(object) {
        return object && typeof object['then'] === 'function';
    }
    _resolveDeferred(deferred, result) {
        if (this._isPromise(result)) {
            result.then((value) => deferred.resolve(value), (reason) => deferred.reject(reason));
        }
        else {
            deferred.resolve(result);
        }
    }
    constructor(deffered) {
        this.deffered = deffered;
    }
    done(callback) {
        this.deffered.done(callback);
        return this;
    }
    fail(callback) {
        this.deffered.fail(callback);
        return this;
    }
    always(callback) {
        this.deffered.always(callback);
        return this;
    }
    state() {
        return this.deffered.state();
    }
    then(onfulfilled, onrejected) {
        const deferred = new DxDeferred();
        this.deffered.then((value) => {
            const result = onfulfilled && onfulfilled(value);
            this._resolveDeferred(deferred, result);
        });
        if (onrejected) {
            this.deffered.catch((value) => {
                const result = onrejected(value);
                this._resolveDeferred(deferred, result);
            });
        }
        else {
            this.deffered.catch((reason) => {
                deferred.reject(reason);
            });
        }
        return deferred.promise();
    }
    catch(onrejected) {
        const deferred = new DxDeferred();
        this.deffered.catch((value) => {
            const result = onrejected && onrejected(value);
            this._resolveDeferred(deferred, result);
        });
        this.deffered.then((value) => {
            deferred.resolve(value);
        });
        return deferred.promise();
    }
}
