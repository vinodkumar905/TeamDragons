/**
* DevExpress Analytics (core\internal\_fetchRequestManager.js)
* Version:  24.1.7
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { toQueryParameters } from '../../serializer/_utils';
import { DxDeferred } from '../utils/_jqueryUtils';
export class FetchRequestManager {
    constructor(fetchSettingsFn) {
        this._executeRequest = (method, url, body, params, abortControler) => {
            const responseDeferred = new DxDeferred();
            const response = this._fetch(method, url, body, params, abortControler);
            response.then(async (response) => {
                const contentType = response.headers.get('content-type')?.split(';')[0];
                if (contentType === 'application/json') {
                    try {
                        const json = await response.json();
                        if (response.ok) {
                            responseDeferred.resolve(json, 'success', { ...responseDeferred.promise(), responseJSON: json });
                        }
                        else {
                            responseDeferred.reject({ ...responseDeferred.promise(), responseJSON: json, statusText: json.statusText, status: response.status }, json.statusText);
                        }
                    }
                    catch (error) {
                        responseDeferred.reject({ ...responseDeferred.promise(), statusText: error.message, status: response.status }, error.message, error);
                    }
                }
                else if (response.ok && contentType) {
                    responseDeferred.resolve({ result: response, success: true });
                }
                else {
                    responseDeferred.reject({ ...responseDeferred.promise(), statusText: response.statusText, status: response.status }, response.statusText);
                }
            }, (error) => {
                responseDeferred.reject({ ...responseDeferred.promise(), statusText: error.message, status: 0 }, error.message);
            });
            return responseDeferred.promise();
        };
        this._fetch = async (method, url, body, params, abortControler) => {
            const settings = {
                method,
                cache: params?.cache,
                headers: params?.headers,
                body,
                signal: abortControler?.signal
            };
            const fetchSettings = this.getFetchSettings();
            fetchSettings && fetchSettings.beforeSend && (await fetchSettings.beforeSend(settings));
            return fetch(url, settings);
        };
        this.useFetch = true;
        this.getFetchSettings = fetchSettingsFn || (() => ({}));
    }
    sendRequest(settings) {
        const { method, preparedUrl, body, params } = this._prepareParams(settings);
        return this._executeRequest(method, preparedUrl, body, params, settings.abortController);
    }
    _prepareParams(settings) {
        const GET = 'GET';
        const POST = 'POST';
        const method = settings.type;
        const data = settings.data;
        let preparedUrl = settings.url;
        let body = null;
        const cache = 'default';
        const queryParams = toQueryParameters(data);
        if (queryParams) {
            if (settings.type === GET) {
                preparedUrl.includes('?') ? preparedUrl += `&${queryParams}` : preparedUrl += `?${queryParams}`;
            }
            else if (settings.type === POST) {
                body = new URLSearchParams(queryParams);
            }
        }
        const params = {
            cache,
            headers: {
                ...settings.headers,
                ...this.getFetchSettings()?.headers
            }
        };
        return { method, preparedUrl, body, params };
    }
}
