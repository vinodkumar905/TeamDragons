/**
* DevExpress Analytics (serializer\_utils.js)
* Version:  24.1.7
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
function isWindow(obj) {
    return obj != null && obj === obj.window;
}
const class2type = {};
const hasOwn = class2type.hasOwnProperty;
['Boolean', 'Number', 'String', 'Function', 'Array', 'Date', 'RegExp', 'Object', 'Error'].forEach(name => class2type['[object ' + name + ']'] = name.toLowerCase());
function type(obj) {
    if (obj == null) {
        return obj + '';
    }
    return typeof obj === 'object' || typeof obj === 'function' ?
        class2type[class2type.toString.call(obj)] || 'object' :
        typeof obj;
}
export function isNumeric(obj) {
    return !isNaN(parseFloat(obj)) && isFinite(obj);
}
export function isPlainObject(obj) {
    if (type(obj) !== 'object' || obj.nodeType || isWindow(obj)) {
        return false;
    }
    return !(obj.constructor && !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf'));
}
export function isEmptyObject(obj) {
    if ((typeof obj) === 'string') {
        return false;
    }
    return obj !== null && typeof obj === 'object' && Object.keys(obj).length === 0;
}
export function isFunction(obj) {
    return type(obj) === 'function';
}
export function extend(_target, object1, ...objectN) {
    let options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, deep = false;
    const length = arguments.length;
    if (typeof target === 'boolean') {
        deep = target;
        target = arguments[i] || {};
        i++;
    }
    if (typeof target !== 'object' && !isFunction(target)) {
        target = {};
    }
    if (i === length) {
        target = this;
        i--;
    }
    for (; i < length; i++) {
        if ((options = arguments[i]) != null) {
            for (name in options) {
                src = target[name];
                copy = options[name];
                if (target === copy) {
                    continue;
                }
                if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                    if (copyIsArray) {
                        copyIsArray = false;
                        clone = src && Array.isArray(src) ? src : [];
                    }
                    else {
                        clone = src && isPlainObject(src) ? src : {};
                    }
                    target[name] = extend(deep, clone, copy);
                }
                else if (copy !== undefined) {
                    target[name] = copy;
                }
            }
        }
    }
    return target;
}
export function toQueryParameters(data) {
    const result = [];
    const objectToParameters = (object, root = '') => {
        Object.keys(object || {}).forEach((key) => {
            const value = object[key];
            const fullPath = root ? `${root}[${key}]` : key;
            if (typeof value === 'object') {
                objectToParameters(object[key], fullPath);
            }
            else {
                result.push(encodeURIComponent(fullPath) + '=' + encodeURIComponent(value));
            }
        });
    };
    objectToParameters(data);
    return result.join('&');
}
export function assignObj(obj, objectProps) {
    return Object.assign(Object.create(Object.getPrototypeOf(obj)), objectProps || obj);
}
