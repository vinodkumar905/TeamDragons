/**
* DevExpress Analytics (property-grid\widgets\ellipsiseditor\_editor.js)
* Version:  24.1.7
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import 'devextreme/ui/text_box';
import dxTextBox from 'devextreme/ui/text_box';
import { addDisposeCallback } from '../../../serializer/_internal';
import { SvgTemplatesEngine } from '../internal/_svgTemplateEngine';
import { KeyboardEnum } from '../internal/_utils';
import registerComponent from 'devextreme/core/component_registrator';
import { $dx, $unwrap } from '../../../core/utils/_jqueryUtils';
const editor_prefix = 'dx-ellipsiseditor', EDITOR_CLASS = editor_prefix + ' dx-dropdowneditor', EDITOR_BUTTON_CLASS = editor_prefix + '-button dx-widget dx-button-normal dx-dropdowneditor-button dx-ellipsis-button', EDITOR_BUTTON_ICON_CLASS = editor_prefix + '-icon dx-ellipsis-image dx-dropdowneditor-icon', EDITOR_BUTTON_ICON_TEMPLATE = 'dxrd-svg-ellipsis', EDITOR_WARNING_STATE_CLASS = 'dx-ellipsiseditor-warning';
export class dxEllipsisEditor extends dxTextBox {
    constructor(element, options) {
        const ellipsisButton = {
            name: 'ellipsisButton',
            location: 'after',
            options: {
                disabled: false,
                template: SvgTemplatesEngine.templates[EDITOR_BUTTON_ICON_TEMPLATE],
                icon: EDITOR_BUTTON_ICON_TEMPLATE,
                onClick: options.buttonAction,
                elementAttr: {
                    class: EDITOR_BUTTON_CLASS
                }
            }
        };
        const clearButton = {
            name: 'clear'
        };
        options.buttons = [
            clearButton,
            ellipsisButton
        ];
        super(element, options);
    }
    _init() {
        super['_init'].apply(this);
        if (!this._$element) {
            this._$element = $dx(this.element());
        }
        this._$element.addClass(EDITOR_CLASS);
    }
    _render() {
        super['_render'].apply(this);
        this._renderButton();
        this._updateWarningState();
        this._attachInputEvents();
    }
    _updateWarningState(value = this.option('warningMessage')) {
        if (value) {
            this._$element.attr('title', value.toString());
            this._$element.addClass(EDITOR_WARNING_STATE_CLASS);
        }
        else {
            this._$element.removeAttr('title');
            this._$element.removeClass(EDITOR_WARNING_STATE_CLASS);
        }
    }
    _updateButtonSize() {
        const height = $dx(this.element()).height();
        this._buttonIcon.style.height = height + 'px';
    }
    _renderButton() {
        const buttonsContainer = $dx(this['_buttonsContainer']());
        const children = buttonsContainer.children();
        const buttonsContainerContent = children[1];
        this._$button = $dx(buttonsContainerContent);
        $dx(this._$button.children()[0]).addClass(EDITOR_BUTTON_ICON_CLASS);
        this._attachButtonEvents();
        this._removeCustomHoveredStyle();
    }
    _attachButtonEvents() {
        if (!this._$input)
            this._$input = $dx(this['_input']());
        const subscribeElements = [];
        if (!this._onClick) {
            this._onClick = (e) => this.buttonAction(e);
        }
        this._$button.off('click', this._onClick);
        this._$input.off('click', this._onClick);
        if (!this.option('disabled'))
            subscribeElements.push(this._$button);
        if (this.option('openOnFieldClick'))
            subscribeElements.push(this._$input);
        subscribeElements.forEach(($element) => {
            $element.on('click', this._onClick);
        });
    }
    _removeCustomHoveredStyle() {
        if (!this._onHover) {
            this._onHover = () => $unwrap(this.element())?.classList.remove('dx-custom-button-hovered');
        }
        this._$button.off('mouseover', this._onHover);
        this._$button.on('mouseover', this._onHover);
    }
    _attachInputEvents() {
        const input = $unwrap(this['_input']());
        if (!input)
            return;
        const handler = (e) => {
            if (e.key == KeyboardEnum.Enter || (e.key == KeyboardEnum.ArrowDown && e.altKey)) {
                this.buttonAction(e);
            }
        };
        input.addEventListener('keydown', handler);
        addDisposeCallback(input, function () {
            input.removeEventListener('keydown', handler);
        });
    }
    _optionChanged(args) {
        switch (args.name) {
            case 'disabled':
                this._attachButtonEvents();
                break;
            case 'warningMessage':
                this._updateWarningState(args.value);
                break;
        }
        super['_optionChanged'].apply(this, arguments);
    }
    buttonAction(e) {
        if (this.option('buttonAction')) {
            this.option('buttonAction')();
            e.stopPropagation();
        }
    }
}
registerComponent('dxEllipsisEditor', dxEllipsisEditor);
