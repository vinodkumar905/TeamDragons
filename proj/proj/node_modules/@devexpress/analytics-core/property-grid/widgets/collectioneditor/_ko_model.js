/**
* DevExpress Analytics (property-grid\widgets\collectioneditor\_ko_model.js)
* Version:  24.1.7
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { CollectionEditorViewModel } from './_editor';
export const wrapModelWithKo = (options, viewModel) => {
    const arrayForWorkComputed = ko.computed(() => ko.isObservableArray(options.values) ? options.values : ko.unwrap(options.values));
    const getOptionsInfoProperty = (propertyName) => !propertyName ? ko.unwrap(options.info)
        : ko.unwrap(options.info) && ko.unwrap(options.info)[propertyName];
    const currentHandler = options.addHandler;
    const addHandler = () => (currentHandler || getOptionsInfoProperty('addHandler')).call(this);
    options.addHandler = () => {
        return addHandler();
    };
    let isUpdate = false;
    const lock = (callback) => {
        if (!isUpdate) {
            isUpdate = true;
            callback();
            isUpdate = false;
        }
    };
    options.onValueChanged = (array, args) => {
        lock(() => {
            args.added?.forEach(change => arrayForWorkComputed().splice(change.index, 0, change.item));
            args.removed?.sort((a, b) => b.index - a.index).forEach(change => arrayForWorkComputed().splice(change.index, 1));
        });
    };
    const collectionEditorModel = new CollectionEditorViewModel({
        ...options,
        values: [...arrayForWorkComputed()()],
        undoEngine: ko.unwrap(options.undoEngine),
        info: ko.unwrap(options.info)
    }, ko.unwrap(viewModel?.disabled));
    if (ko.isSubscribable(viewModel?.disabled)) {
        collectionEditorModel._disposables.push(viewModel.disabled.subscribe((newVal) => {
            collectionEditorModel.disabled = newVal;
        }));
    }
    collectionEditorModel._disposables.push(arrayForWorkComputed);
    const createArraySubscription = () => arrayForWorkComputed().subscribe((changes) => {
        lock(() => {
            changes.forEach(change => {
                if (change.status === 'added') {
                    collectionEditorModel.values.splice(change.index, 0, change.value);
                }
                if (change.status === 'deleted') {
                    collectionEditorModel.values.splice(change.index, 1);
                }
            });
        });
    }, undefined, 'arrayChange');
    let currentArraySubscription = createArraySubscription();
    collectionEditorModel._disposables.push(currentArraySubscription);
    collectionEditorModel._disposables.push(arrayForWorkComputed.subscribe((newVal) => {
        lock(() => {
            currentArraySubscription.dispose();
            collectionEditorModel.values = [...ko.unwrap(newVal)];
            currentArraySubscription = createArraySubscription();
            collectionEditorModel._disposables.push(currentArraySubscription);
        });
    }));
    if (viewModel && ko.isSubscribable(viewModel.disabled)) {
        collectionEditorModel._disposables.push(viewModel.disabled.subscribe(newVal => {
            collectionEditorModel.disabled = ko.unwrap(viewModel.disabled);
        }));
    }
    return collectionEditorModel;
};
