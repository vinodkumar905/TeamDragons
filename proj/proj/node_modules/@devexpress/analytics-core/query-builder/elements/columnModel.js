/**
* DevExpress Analytics (query-builder\elements\columnModel.js)
* Version:  24.1.7
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import * as ko from 'knockout';
import { QueryElementBaseViewModel } from './queryElementModel';
import { AggregationType, columnSerializationInfo } from './columnModelMeta';
import { DBColumn, DBColumnType } from '../dataSource/dbColumn';
import { PointSide } from '../../diagram/utils';
import { ColumnExpressionCollectionHelper } from '../utils/_columnExpressionCollectionHelper';
import { extend } from '../../serializer/_utils';
export class ColumnViewModel extends QueryElementBaseViewModel {
    _isAliasAutoGenerated(addedTableName) {
        if (addedTableName && this.alias() && this.alias().indexOf(addedTableName + '_') === 0) {
            if (this.alias().substring(addedTableName.length + 1) === this.name())
                return true;
        }
        if (!this.alias() || this.alias().indexOf(this.name() + '_') !== 0)
            return false;
        let funcName = this.alias().substring(this.name().length + 1);
        if (funcName.match(new RegExp('_[0-9]+$')))
            funcName = funcName.substring(0, funcName.indexOf('_'));
        return Object.keys(AggregationType).indexOf(funcName) > 0;
    }
    getInfo() {
        return columnSerializationInfo;
    }
    constructor(model, dbColumn, parent, serializer) {
        super(extend({ '@ControlType': 'Column' }, model), parent, serializer);
        this.isNotAvailable = ko.observable(false);
        this._type = ko.observable(DBColumnType.Unknown);
        this._size = ko.observable('');
        if (dbColumn.size)
            this._size(dbColumn.size);
        if (dbColumn.type)
            this._type(dbColumn.type);
        this.displayType = ko.pureComputed(() => {
            return DBColumnType[this._type()] + (this._size() ? '(' + this._size() + ')' : '');
        });
        this.dataType = ko.pureComputed(() => {
            return DBColumn.GetType(this._type());
        });
        this.actualName = ko.pureComputed(() => {
            return this.alias() || this.name();
        });
        const points = parent.getColumnConnectionPoints(this);
        this.rightConnectionPoint = {
            side: ko.observable(PointSide.East),
            location: points.right
        };
        this.leftConnectionPoint = {
            side: ko.observable(PointSide.West),
            location: points.left
        };
        const query = parent.parentModel();
        const targetColumn = ko.pureComputed(() => ColumnExpressionCollectionHelper.find(query.columns, parent.actualName(), this.name()));
        this.aggregate = ko.pureComputed({
            read: () => targetColumn() ? targetColumn().aggregate() : AggregationType.None,
            write: (value) => {
                targetColumn() && targetColumn().aggregate(value);
            }
        });
        this.alias = ko.pureComputed({
            read: () => targetColumn() ? targetColumn().alias() : '',
            write: (value) => {
                targetColumn() && targetColumn().alias(value || null);
            }
        });
        const orderByItem = ko.pureComputed(() => ColumnExpressionCollectionHelper.find(query.sorting, parent.actualName(), this.name()));
        this.sortingType = ko.computed({
            read: () => {
                if (!orderByItem())
                    return 'Unsorted';
                return orderByItem().descending() ? 'Descending' : 'Ascending';
            },
            write: (newValue) => {
                if (newValue !== 'Unsorted') {
                    if (orderByItem()) {
                        orderByItem().descending(newValue === 'Descending');
                    }
                    else {
                        ColumnExpressionCollectionHelper.addNew(query, query.sorting, parent.actualName(), this.name())
                            .descending(newValue === 'Descending');
                    }
                }
                else if (orderByItem()) {
                    ColumnExpressionCollectionHelper.remove(query.sorting, parent.actualName(), this.name());
                }
            }
        });
        this.sortOrder = ko.computed({
            read: () => {
                const index = query.sorting().indexOf(orderByItem());
                return index < 0 ? undefined : index + 1;
            },
            write: (newValue) => {
                if (!orderByItem())
                    return;
                newValue = Math.min(newValue, query.sorting().length);
                newValue = Math.max(newValue, 1);
                const oldValue = query.sorting().indexOf(orderByItem());
                const item = query.sorting.splice(oldValue, 1);
                query.sorting.splice(newValue - 1, 0, item[0]);
            }
        });
        const groupByItem = ko.computed(() => ColumnExpressionCollectionHelper.find(query.grouping, parent.actualName(), this.name()));
        this.aggregate.subscribe((value) => {
            const parentTable = this.parentModel();
            if (value !== AggregationType.None) {
                this.groupBy(false);
                if (!this.alias() || this._isAliasAutoGenerated(parentTable.actualName())) {
                    const aggregateAlias = this.name() + '_' + value;
                    this.alias(ColumnExpressionCollectionHelper.setUniqueAlias(query.columns, aggregateAlias));
                }
            }
            else if (this._isAliasAutoGenerated(parentTable.actualName())) {
                this.alias(null);
            }
        });
        this.groupBy = ko.computed({
            read: () => !!groupByItem(),
            write: (value) => {
                if (value) {
                    ColumnExpressionCollectionHelper.addNew(query, query.grouping, parent.actualName(), this.name());
                    this.aggregate(AggregationType.None);
                }
                else {
                    ColumnExpressionCollectionHelper.remove(query.grouping, parent.actualName(), this.name());
                }
            }
        });
        this.toggleSelected = (value, lazy = false) => {
            if (!!targetColumn() === value)
                return;
            if (value) {
                ColumnExpressionCollectionHelper.addNew(query, query.columns, parent.actualName(), this.name(), lazy);
            }
            else {
                ColumnExpressionCollectionHelper.remove(query.columns, parent.actualName(), this.name(), lazy);
                this.groupBy(false);
            }
        };
        this.selected = ko.pureComputed({
            read: () => !!targetColumn(),
            write: (value) => this.toggleSelected(value)
        });
    }
    isPropertyDisabled(name) {
        if (this.isNotAvailable())
            return true;
        if (name === 'sortOrder') {
            return this.sortingType() === 'Unsorted';
        }
        else if (name === 'aggregate' || name === 'alias') {
            return !this.selected();
        }
        else if (name === 'groupBy') {
            const query = this.root;
            return this.aggregate() && query.aggregatedColumnsCount() === 1;
        }
        else
            return false;
    }
    get specifics() {
        return DBColumn.GetSpecific(this.dataType());
    }
}
