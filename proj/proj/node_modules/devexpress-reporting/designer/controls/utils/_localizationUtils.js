/**
* DevExpress HTML/JS Reporting (designer\controls\utils\_localizationUtils.js)
* Version:  24.1.7
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { formatUnicorn } from '@devexpress/analytics-core/analytics-internal';
import { Disposable } from '@devexpress/analytics-core/analytics-utils';
import * as ko from 'knockout';
export function __createLocalizationProperties(target, format = '{0}') {
    return target.getInfo().filter(x => x.localizable && x.modelName).map(x => {
        return new LocalizedProperty(formatUnicorn(format, x.modelName.substr(1)), target['_' + x.propertyName] || target[x.propertyName], x, target);
    });
}
export class DefaultLocalizationProvider extends Disposable {
    dispose() {
        this._localizationInfo = null;
    }
    constructor(_model) {
        super();
        this._model = _model;
    }
    getLocalizationProperty(propertyName) {
        return this.getLocalizationProperties().filter(x => x.propertyName === propertyName)[0];
    }
    getLocalizationProperties() {
        if (!this._localizationInfo) {
            this._localizationInfo = __createLocalizationProperties(this._model);
        }
        return this._localizationInfo;
    }
    applyLocalization(propertyName, propertyValue) {
        this.getLocalizationProperties().filter(x => x.propertyName === propertyName).forEach((x) => x.applyLocalization(propertyValue));
    }
}
export class TableOfContentLocalizationProvider extends DefaultLocalizationProvider {
    getLocalizationProperties() {
        if (!this._localizationInfo) {
            this._localizationInfo = [].concat.apply(super.getLocalizationProperties(), [
                __createLocalizationProperties(this._model.levelTitle, 'LevelTitle.{0}')
            ]);
        }
        return [].concat.apply(this._localizationInfo, this._model.levels().map((level, i) => {
            return __createLocalizationProperties(level, formatUnicorn('Levels.{0}.', i) + '{0}');
        }));
    }
}
export class ReportLocalizationProvider extends DefaultLocalizationProvider {
    getLocalizationProperties() {
        if (!this._localizationInfo) {
            this._localizationInfo = super.getLocalizationProperties();
        }
        const itemsLocalization = this._model.watermarks().map((watermark) => __createLocalizationProperties(watermark, formatUnicorn('Watermarks.{0}.', ko.unwrap(watermark.watermarkId)) + '{0}'));
        this._model.parameters().forEach(p => {
            const isStaticLookUp = ko.unwrap(p.valueSourceSettingsType) === 'StaticListLookUpSettings';
            const settings = ko.unwrap(p.valueSourceSettings);
            if (isStaticLookUp && settings) {
                settings['lookUpValues']().forEach((v, i) => {
                    itemsLocalization.push(__createLocalizationProperties(v, formatUnicorn('{0}.LookUpValues[{1}].Description', ko.unwrap(p.name), ko.unwrap(i))));
                });
            }
        });
        return [].concat.apply(this._localizationInfo, itemsLocalization);
    }
}
export class ChartLocalizationProvider extends DefaultLocalizationProvider {
    getLocalizationProperties() {
        const chartComponents = this._model.allChartComponents();
        return [].concat.apply(super.getLocalizationProperties(), chartComponents.map(componentInfo => {
            return __createLocalizationProperties(componentInfo.component, componentInfo.path + '.{0}');
        }));
    }
}
export class LocalizedProperty {
    constructor(propertyName, value, info, target) {
        this.propertyName = propertyName;
        this.value = value;
        this.info = info;
        this.target = target;
    }
    applyLocalization(value) {
        const newValue = this.info.from ? ko.unwrap(this.info.from(value)) : value;
        const componentValueAsValue = ko.unwrap(this.value);
        if (this.value.getInfo) {
            const info = componentValueAsValue.getInfo();
            info.forEach(info => {
                componentValueAsValue[info.propertyName] && componentValueAsValue[info.propertyName](newValue[info.propertyName]());
            });
        }
        else {
            this.value(newValue);
        }
    }
}
