/**
* DevExpress HTML/JS Reporting (designer\controls\xrReport.d.ts)
* Version:  24.1.7
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { IArea, IElementViewModel, IMargins, INumericSize, ISurfaceContext, Margins, SurfaceElementArea } from '@devexpress/analytics-core/analytics-elements';
import { FieldListProvider, IHoverInfo, ISelectionTarget, IUnitProperties, MeasureUnit, SurfaceSelection } from '@devexpress/analytics-core/analytics-internal';
import { IModelReady, IModelSerializer, UndoEngine } from '@devexpress/analytics-core/analytics-utils';
import * as ko from 'knockout';
import { IEnumType } from '../../common/customTypes';
import { ExportOptions } from '../../common/exportOptions/exportOptions';
import { BandSurface, BandViewModel } from '../bands/xrBand';
import { BandsHolder } from '../bands/_bandHolder';
import { CalculatedField } from '../dataObjects/calculatedField';
import { ObjectsStorage } from '../dataObjects/objectStorage';
import { ObjectStorageItem } from '../dataObjects/objectStorageItem';
import { ParameterPanelLayoutItem } from '../dataObjects/parameters/layoutItems';
import { Parameter } from '../dataObjects/parameters/parameter';
import { ReportParameterHelper } from '../helpers/reportParameterHelper';
import { DataSourceHelper } from '../helpers/_dataSourceHelper';
import { StylesHelper } from '../helpers/_styleHelper';
import { LocalizationItem } from '../localization/_localization';
import { ReportLocalizationEngine } from '../localization/_localizationEngine';
import { IDataSourceRefInfo } from '../utils/inititalizer';
import { ComponentsModel } from './properties/components';
import { ExtensionModel } from './properties/extension';
import { FormattingRule } from './properties/formattingrules';
import { StyleModel } from './properties/style';
import { WatermarkModel } from './properties/watermark';
import { ControlType, ReportBandsType } from './utils/_controlTypes';
import { ReportLocalizationProvider } from './utils/_localizationUtils';
import { XRCrossBandControlViewModel, XRCrossBandSurface } from './xrCrossband';
import { XRReportElementViewModel } from './xrReportelement';
export declare class ReportViewModel extends XRReportElementViewModel implements IModelReady {
    static availableDataSourceTypes: string[];
    static bandsTypeOrdering: ReportBandsType[];
    static unitProperties: string[];
    static defaultPageSize: {
        width: number;
        height: number;
    };
    static createObjectStorage(_componentStorage: ko.ObservableArray<ObjectStorageItem>, _objectStorage: ko.ObservableArray<ObjectStorageItem>, collectSubscription?: (subscription: ko.Subscription) => any): ko.ObservableArray<ObjectStorageItem>;
    private _getDpi;
    private _recalculateUnits;
    private _updatePageSize;
    enumerateComponents(process?: (target: ko.ObservableArray<any>) => void): any[];
    createLocalizationProvider(): ReportLocalizationProvider;
    createReportViewModel(report: any, serializer?: IModelSerializer): ReportViewModel;
    findStyle(styleName: string): StyleModel;
    _getBandForToc(bands: BandViewModel[]): BandViewModel;
    getOrCreateBandForToC(createNew?: boolean): {
        band: BandViewModel;
        canAdd: boolean;
    };
    canAddToC(): boolean;
    _initializeBands(): void;
    isPropertyDisabled(name: string): boolean;
    dispose(): void;
    preInitProperties(): void;
    constructor(report: any, serializer?: IModelSerializer, knownEnums?: IEnumType[]);
    isLocalized(): boolean;
    initialize(): void;
    getNearestParent(target: IElementViewModel<ControlType>): ReportViewModel;
    addChild(control: IElementViewModel): void;
    removeChild(control: IElementViewModel): void;
    clearLocalization(culture?: string): void;
    serialize(): any;
    save(): any;
    getPath(propertyName: string): string;
    clone(dataSourceRefsFromParent?: IDataSourceRefInfo[]): ReportViewModel;
    paperKind: ko.Observable<string> | ko.Computed<string>;
    isStyleProperty(propertyName: string): boolean;
    onSave: (data: any) => void;
    dataSourceHelper: ko.Observable<DataSourceHelper>;
    dataBindingsProvider: ko.Observable<FieldListProvider>;
    stylesHelper: ko.Observable<StylesHelper>;
    dataSource: ko.Observable<ObjectStorageItem>;
    dataMember: ko.Observable<string> | ko.Computed<string>;
    styles: ko.ObservableArray<StyleModel>;
    measureUnit: ko.Observable<MeasureUnit> | ko.Computed<MeasureUnit>;
    snapGridSize: ko.Observable<number> | ko.Computed<number>;
    pageWidth: ko.Observable<number> | ko.Computed<number>;
    pageHeight: ko.Observable<number> | ko.Computed<number>;
    margins: Margins;
    bands: ko.ObservableArray<BandViewModel>;
    crossBandControls: ko.ObservableArray<XRCrossBandControlViewModel>;
    parameters: ko.ObservableArray<Parameter>;
    parameterPanelLayoutItems: ko.ObservableArray<ParameterPanelLayoutItem>;
    parameterHelper: ReportParameterHelper;
    objectsStorageHelper: ObjectsStorage;
    objectStorage: ko.ObservableArray<ObjectStorageItem>;
    _objectStorage: ko.ObservableArray<ObjectStorageItem>;
    _componentStorage: ko.ObservableArray<ObjectStorageItem>;
    _dataBindingMode: ko.Observable<string> | ko.Computed<string>;
    get dataBindingMode(): string;
    extensions: ko.ObservableArray<ExtensionModel>;
    formattingRuleSheet: ko.ObservableArray<FormattingRule>;
    components: ko.ObservableArray<ComponentsModel>;
    calculatedFields: ko.ObservableArray<CalculatedField>;
    watermarks: ko.ObservableArray<WatermarkModel>;
    scriptsSource: ko.Observable<string> | ko.Computed<string>;
    scriptLanguage: ko.Observable<string> | ko.Computed<string>;
    private _getReportUnit;
    private _update;
    surface: ReportSurface;
    exportOptions: ExportOptions;
    isModelReady: ko.Computed<boolean>;
    scriptReferencesString: ko.Computed<string>;
    landscape: ko.Observable<boolean> | ko.Computed<boolean>;
    _scriptReferencesString: ko.Observable<string> | ko.Computed<string>;
    key: ko.Computed<string>;
    dataSourceRefs: Array<IDataSourceRefInfo>;
    knownEnums?: Array<IEnumType>;
    rtlLayout: ko.Observable<string> | ko.Computed<string>;
    drawWatermark: ko.Observable<boolean> | ko.Computed<boolean>;
    displayNameObject: ko.Observable<string>;
    _localizationItems: ko.ObservableArray<LocalizationItem>;
    _localization: ReportLocalizationEngine;
    language: ko.Observable<string>;
}
export declare class ReportSurface extends SurfaceElementArea<ReportViewModel, ControlType> implements ISelectionTarget, ISurfaceContext {
    private report;
    static _unitProperties: IUnitProperties<ReportViewModel>;
    private _createMargin;
    private _updateWatermarkImageNaturalSize;
    get _unitAbsoluteRect(): IArea;
    dispose(): void;
    private _watermarkSubscriptions;
    get watermark(): WatermarkModel;
    private _assignSelectedWatermark;
    constructor(report: ReportViewModel, zoom?: ko.Observable<number>);
    surfaceContextMenuHandler: (selection: SurfaceSelection, surface: ReportSurface, e: PointerEvent) => void;
    getChildrenCollection(): ko.ObservableArray<BandSurface>;
    isFit(dropTarget: ISelectionTarget): boolean;
    canDrop(): boolean;
    wrapRtlProperty(data: {
        value: ko.Observable | ko.Computed;
    }, undoEngine: ko.Observable<UndoEngine> | ko.Computed<UndoEngine>, element: Element): {
        value: ko.Observable | ko.Computed;
    };
    clickHandler(selection: SurfaceSelection, e: PointerEvent): void;
    reportContextMenuHandler(selection: SurfaceSelection, e: PointerEvent): void;
    allowMultiselect: boolean;
    locked: boolean;
    focused: ko.Observable<boolean>;
    selected: ko.Observable<boolean>;
    templateName: ko.Observable<string>;
    bandsHolder: BandsHolder;
    underCursor: ko.Observable<IHoverInfo>;
    crossBandControls: ko.ObservableArray<XRCrossBandSurface>;
    measureUnit: ko.Observable<MeasureUnit> | ko.Computed<MeasureUnit>;
    zoom: ko.Observable<number> | ko.Computed<number>;
    margins: IMargins;
    dpi: ko.Observable<number> | ko.Computed<number>;
    rtl: ko.Observable<boolean> | ko.Computed<boolean>;
    pageWidthWithoutMargins: ko.Computed<number>;
    ghostContainerOffset: ko.Computed<number>;
    checkParent(surfaceParent: ISelectionTarget): boolean;
    effectiveHeight: ko.Computed<number>;
    minHeight: ko.Observable<number>;
    maxMarkerWidth: ko.Observable<number>;
    pageWidth: ko.Observable<number> | ko.Computed<number>;
    pageHeight: ko.Observable<number> | ko.Computed<number>;
    validationMode: ko.Observable<boolean>;
    parent: ISelectionTarget;
    leftMarginOffset: ko.Computed<number>;
    rightMarginOffset: ko.Computed<number>;
    rightMarginResizableOffset: ko.Computed<number>;
    rightMarginResizeOptions: (undoEngine: ko.Observable<UndoEngine>, element: Element) => {};
    leftMarginResizeOptions: (undoEngine: ko.Observable<UndoEngine>, element: Element) => {};
    leftMarginResizableOffset: ko.Computed<number>;
    drawWatermark: ko.Observable<boolean> | ko.Computed<boolean>;
    _watermarkImageNaturalSize: ko.Observable<INumericSize>;
    _watermarkTextRenderingResult: ko.Observable<string> | ko.Computed<string>;
}
