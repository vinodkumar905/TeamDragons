/**
* DevExpress HTML/JS Reporting (designer\widgets\pivotGridCriteriaEditor.js)
* Version:  24.1.7
* Build date: Oct 28, 2024
* Copyright (c) 2012 - 2024 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
import { DxDeferred, find, getFullPath } from '@devexpress/analytics-core/analytics-internal';
import { PathRequest } from '@devexpress/analytics-core/analytics-utils';
import { Editor } from '@devexpress/analytics-core/analytics-widgets';
import * as ko from 'knockout';
import { Parameter } from '../dataObjects/parameters/parameter';
export class PivotGridCriteriaEditor extends Editor {
    _createItemsProvider(fieldListProvider) {
        return {
            getItems: (pathRequest) => {
                const model = this._get('_model', 'peek');
                if (!model || pathRequest.fullPath.indexOf(Parameter.ParametersRefString) === 0)
                    return new DxDeferred().resolve().promise();
                const pivot = model['parent'];
                const result = new DxDeferred();
                const fullPath = new PathRequest(getFullPath(pivot.getPath(''), pivot.dataMember()));
                ko.unwrap(fieldListProvider).getItems(fullPath).done((dataSourceItems) => {
                    const items = [], fields = pivot.fields();
                    for (let i = 0; i < fields.length; i++) {
                        const field = fields[i];
                        if (field.area() === 'DataArea') {
                            continue;
                        }
                        const dataMemberInfo = dataSourceItems.filter((item) => { return item.name === field.fieldName(); })[0];
                        items.push({
                            displayName: field.getDisplayName(),
                            isList: false,
                            name: field.name(),
                            specifics: dataMemberInfo && dataMemberInfo.specifics.toLowerCase() || 'integer'
                        });
                    }
                    result.resolve(items);
                });
                return result.promise();
            }
        };
    }
    _getFieldName(name, isRealName = false) {
        const model = this._get('_model', 'peek');
        if (!model)
            return new DxDeferred().resolve().promise();
        const pivot = model['parent'];
        const field = find(pivot.fields.peek(), f => (isRealName ? (f.getDisplayName() || name) : f.name()) === name);
        const def = new DxDeferred();
        if (!field)
            def.reject();
        else
            def.resolve(isRealName ? field.name() : field.getDisplayName());
        return def.promise();
    }
    _createDisplayNameProvider() {
        return {
            getDisplayNameByPath: (path, name) => {
                return this._getFieldName(name);
            },
            getRealName: (path, name) => {
                return this._getFieldName(name, true);
            }
        };
    }
    constructor(info, level, parentDisabled, textToSearch) {
        super(info, level, parentDisabled, textToSearch);
    }
    wrapModel(fieldListProvider) {
        if (!this.itemsProvider) {
            this.itemsProvider = this._createItemsProvider(fieldListProvider);
            this.displayNameProvider = this._createDisplayNameProvider();
        }
        return this;
    }
}
